# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'main.py'
#
# Created by: PyQt5 UI code generator 5.15.1
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.

import sys
import os
import cv2 as cv
import xlrd
from PyQt5.QtWidgets import QMainWindow, QDesktopWidget, \
    QApplication, QFileDialog, QLabel, QWidget, \
    QAbstractItemView, QTableWidgetItem, QShortcut, QDialog
from PyQt5.QtCore import Qt, QTimer, QSize, pyqtSignal
from PyQt5.QtGui import QPixmap, QImage, QKeySequence, QTextCursor, QFont, QIcon
import dlib
from New import Ui_New
from CH import Ui_Form
from info import Ui_info


class Camera(QMainWindow, Ui_New):
    cap = 0
    # 判断摄像头是否打开
    camera_on = False

    # 计时器生成视频
    timer = 0

    # 人脸识别模型
    detector = 0
    predictor = 0

    # 建立图形库
    num_photo = 0
    photo_arr = []
    name_arr = []
    name = "1213"

    # 标准图片库
    Stand_img = []
    cnt_stand = 0

    # 当前打开文件名
    current_file = 0

    # 拍照到第几位同学
    cnt_student = 0

    pd_k = 0
    pd_top = 0
    pd_left = 0
    autoswichs = 0

    info = 0
    change = 0

    def __init__(self, parent=None):
        super(Camera, self).__init__(parent)
        self.setWindowIcon(QIcon("source/IC.jpg"))
        self.setWindowTitle("Camera")
        self.setContextMenuPolicy(Qt.NoContextMenu)
        self.screen = QDesktopWidget().screenGeometry()
        self.setupUi(self)
        self.initUi()

    def initUi(self):
        self.stand_photo_init()
        self.strartimer()
        self.photograph.clicked.connect(self.take)
        self.autophotograph_2.clicked.connect(self.auto_start)
        self.addClass.clicked.connect(self.openxlsx)
        self.next_stand.clicked.connect(self.stand_photo_next)
        self.last_stand.clicked.connect(self.stand_photo_last)
        self.addStand.clicked.connect(self.add_stand_photo)
        self.init_action()
        # self.set_table_style()

        xsmap = QPixmap("source/last.jpg")
        icon1 = QIcon(xsmap.scaled(999, 999, Qt.KeepAspectRatio, Qt.SmoothTransformation))
        self.last_stand.setIcon(icon1)
        self.last_stand.setIconSize(QSize(72, 72))

        icon2 = QIcon()
        icon2.addPixmap(QPixmap("source/next.jpg"), QIcon.Normal, QIcon.Off)
        self.next_stand.setIcon(icon2)
        self.next_stand.setIconSize(QSize(72, 72))

        # 将单元格绑定右键菜单
        # 点击单元格，调用 self.generateMenu 函数
        # self.Photo.setContextMenuPolicy(Qt.CustomContextMenu)
        # self.Photo.customContextMenuRequested.connect(self.generate_menu)

        # 设置学生名单框架属性
        self.StudentList.setSelectionBehavior(QAbstractItemView.SelectRows)  # 单击选中一行
        self.StudentList.setSelectionMode(QAbstractItemView.SingleSelection)  # 只能选中一行
        self.StudentList.setAlternatingRowColors(True)  # 设置隔一行变一颜色，即：一灰一白
        self.StudentList.setEditTriggers(QAbstractItemView.NoEditTriggers)  # 设置每行内容不可更改

        self.NoPhooto_StudentList.setSelectionBehavior(QAbstractItemView.SelectRows)  # 单击选中一行
        self.NoPhooto_StudentList.setSelectionMode(QAbstractItemView.SingleSelection)  # 只能选中一行
        self.NoPhooto_StudentList.setAlternatingRowColors(True)  # 设置隔一行变一颜色，即：一灰一白
        self.NoPhooto_StudentList.setEditTriggers(QAbstractItemView.NoEditTriggers)  # 设置每行内容不可更改

        # 设置消息栏属性
        font = QFont()
        font.setFamily("Arial")
        font.setPointSize(13)
        self.Message_bar.setFont(font)

    '''
    def generate_menu(self, pos):
        row_num = col_num = -1
        # 获取选中的单元格的行数以及列数
        for i in self.Photo.selectionModel().selection().indexes():
            row_num = i.row()
            col_num = i.column()
        k = row_num * 4 + col_num
        # 若选取的单元格中有元素，则支持右键菜单
        if (k < self.num_photo):
            menu = QMenu()
            item1 = menu.addAction('查看图片')
            item2 = menu.addAction('删除图片')

            # 获取选项
            action = menu.exec_(self.Photo.mapToGlobal(pos))
            if action == item1:
                self.show_photo()
            elif action == item2:
                self.delete_photo(k)

    def show_photo(self):
        k = self.Photo.currentRow() * 4 + self.Photo.currentColumn()
        cv.cvtColor(self.photo_arr[k], cv.COLOR_RGB2BGR, self.photo_arr[k])
        cv.namedWindow(self.name_arr[k], 1)
        cv.imshow(self.name_arr[k], self.photo_arr[k])
        cv.cvtColor(self.photo_arr[k], cv.COLOR_BGR2RGB, self.photo_arr[k])

    def delete_photo(self, k):
        self.photo_arr.pop(k)
        self.num_photo -= 1
        self.makeup()

    def set_table_style(self):
        # 开启水平与垂直滚轴
        self.Photo.setVerticalScrollBarPolicy(Qt.ScrollBarAlwaysOn)
        self.Photo.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOn)
        # 设置 40 行 4 列 的表格
        self.Photo.setColumnCount(4)
        self.Photo.setRowCount(60)

        for i in range(4):
            self.Photo.setColumnWidth(i, 60)
        # 设置单元格的高度
        # 设置纵横比为 4 : 3
        for i in range(40):
            self.Photo.setRowHeight(i, 80)

        # 隐藏标题栏
        self.Photo.verticalHeader().setVisible(False)
        self.Photo.horizontalHeader().setVisible(False)
        # 禁止编辑
        self.Photo.setEditTriggers(QAbstractItemView.NoEditTriggers)
        self.Photo.itemDoubleClicked.connect(self.show)
'''

    def init_action(self):
        take_photo = QShortcut(QKeySequence("Ctrl+C"), self)
        take_photo.activated.connect(self.take)
        self.addbar.triggered.connect(self.openxlsx)

        self.layout.triggered.connect(self.add_stand_photo)

    def message_send(self, k):
        if k == 1:
            if (self.num_photo > 0) & (self.name_arr[self.num_photo - 1] != "default"):
                self.Message_bar.insertPlainText("> " + self.name_arr[self.num_photo - 1] + " 拍照成功!\n\n")
            else:
                self.Message_bar.insertPlainText("> 拍照成功(未选中名字)\n\n")
            self.Message_bar.moveCursor(QTextCursor.Start)
        if k == 2:
            self.Message_bar.insertPlainText("> 导入名单成功!\n")
            self.Message_bar.moveCursor(QTextCursor.Start)
        if k == 3:
            self.Message_bar.insertPlainText("> 导入文件  ")
            self.Message_bar.insertPlainText(self.current_file + "\n\n")
            self.Message_bar.moveCursor(QTextCursor.Start)
        if k == 4:
            self.Message_bar.insertPlainText("> 未识别到人脸\n\n")
            self.Message_bar.moveCursor(QTextCursor.Start)

    # 导出图片
    def write(self):
        file_name = QFileDialog.getExistingDirectory(self, "选取文件夹", ".")

        for kk in range(self.num_photo):
            cv.cvtColor(self.photo_arr[kk], cv.COLOR_RGB2BGR, self.photo_arr[kk])
            cv.imwrite(file_name + "/" + str(kk + 1) + "." + self.name_arr[kk] + ".jpg", self.photo_arr[kk])
            cv.cvtColor(self.photo_arr[kk], cv.COLOR_BGR2RGB, self.photo_arr[kk])

        self.Message_bar.insertPlainText("> 导出图片成功\n\n")
        self.Message_bar.moveCursor(QTextCursor.Start)
        return

    # 打开xlsx文件
    def openxlsx(self):
        fnames, _ = QFileDialog.getOpenFileNames(self, 'Open files', './', 'xlsx File(*.xlsx);;xls File(*.xls)')
        if not fnames:
            return

        self.current_file = fnames[0]
        self.message_send(3)
        workbook = xlrd.open_workbook(fnames[0])

        while self.StudentList.rowCount() > 0:
            self.StudentList.removeRow(0)

        while self.NoPhooto_StudentList.rowCount() > 0:
            self.NoPhooto_StudentList.removeRow(0)

        self.StudentList.setHorizontalHeaderLabels(
            ['姓名', '学号'])
        self.NoPhooto_StudentList.setHorizontalHeaderLabels(
            ['姓名', '学号'])

        sheet1 = workbook.sheet_by_index(0)
        cols = sheet1.col_values(1)
        tot = len(cols)
        for i in range(1, tot):
            row = self.StudentList.rowCount()
            self.StudentList.insertRow(row)
            row = self.NoPhooto_StudentList.rowCount()
            self.NoPhooto_StudentList.insertRow(row)

        # 获取整行和整列的值（数组）
        for i in range(1, tot):
            rowslist = sheet1.row_values(i)  # 获取excel每行内容
            for j in range(len(rowslist)):
                # 把数据写入tablewidget中
                s = str(rowslist[j])
                newItem = QTableWidgetItem(s)
                self.StudentList.setItem(i - 1, j, newItem)
                self.NoPhooto_StudentList.setItem(i - 1, j, QTableWidgetItem(s))
                # self.StudentList.setItem(i-1, j, QTableWidgetItem("asdasd"))
        self.set_New_name()
        self.message_send(2)

    def strartimer(self):
        self.timer = QTimer()
        self.timer.start()  # 实时刷新，不然视频不动态
        self.timer.setInterval(50)

        self.cap = cv.VideoCapture(0)  # 开启摄像头
        self.timer.timeout.connect(self.videos)
        self.cap.set(3, 1600)
        self.cap.set(4, 1200)
        # 识别模型加载
        # self.Gpu()
        self.detector = dlib.get_frontal_face_detector()
        predictor_path = r'shape_predictor_68_face_landmarks.dat'
        self.predictor = dlib.shape_predictor(predictor_path)

    def videos(self):

        if self.cap.isOpened():
            ret, img = self.cap.read()
            img = cv.transpose(img)
            img = cv.flip(img, 0)
            img = cv.flip(img, 1)
            img_r = cv.resize(img, (0, 0), fx=0.5, fy=0.5, interpolation=cv.INTER_LINEAR)

            img_gray = cv.cvtColor(img_r, cv.COLOR_RGB2GRAY)

            # 人脸数
            faces = self.detector(img_gray, 0)

            max_area = 0
            max_face = 0
            # 检测到人脸
            if len(faces) > 0:
                # 记录每次开始写入人脸像素的宽度位置
                for k, face in enumerate(faces):
                    height = face.bottom() - face.top()
                    width = face.right() - face.left()
                    area = height * width
                    if area > max_area:
                        max_area = area
                        max_face = face

                face = max_face
                # 绘制脸部矩形框
                Length = face.right() - face.left()
                width = face.bottom() - face.top()

                Length = int(Length * 1)
                width = int(width * 0.9)
                # Length = 0
                # width = 0
                op = 2
                Length *= op
                unm = Length * 4 // 3
                mid_left = (face.right() + face.left()) * op // 2
                mid_top = (face.top() + face.bottom()) * op // 2
                # cv.rectangle(img, tuple([(mid_left - Length), int(mid_top - unm)]),
                #             tuple([(mid_left + Length), int(mid_top + unm)]), (0, 255, 255), 2)

                h, w, bytesPerComponent = img.shape
                top = max(mid_top - unm, 0)
                bottom = min(mid_top + unm, h)
                left = max(mid_left - Length, 0)
                right = min(mid_left + Length, w)


                # 截取头像图片
                if self.autoswichs == 1:
                    self.pd_k += 1
                    if self.pd_k < 10:
                        cv.putText(img, "Ready for photography, Please keep stable", (0, 50), cv.FONT_HERSHEY_SIMPLEX,
                                   1, (255, 255, 255), 2)
                        if (self.pd_top == top) & (self.pd_left == left):
                            self.pd_k += 1
                        else:
                            self.pd_k = 1
                            self.pd_top = top
                            self.pd_left = left
                    else:
                        if self.pd_k == 10:
                            img_s = img[top:bottom, left:right]
                            cv.imwrite(path + "/source/kk1.jpg", img_s)

                        if self.pd_k == 15:
                            img_s = img[top:bottom, left:right]
                            cv.imwrite(path + "/source/kk2.jpg", img_s)

                        if self.pd_k == 20:
                            img_s = img[top:bottom, left:right]
                            cv.imwrite(path + "/source/kk3.jpg", img_s)

                            item = self.NoPhooto_StudentList.item(0, 0)
                            name = "default"
                            if item is not None:
                                n1 = self.NoPhooto_StudentList.item(0, 0).text()
                                n2 = self.NoPhooto_StudentList.item(0, 1).text()
                                # name = n1 + "_" + n2
                                name = n2
                                # self.NoPhooto_StudentList.removeRow(0)
                            else:
                                self.auto_start()
                                return
                            self.info = Info(name)
                            self.info.mySignal.connect(self.getEnd)
                            self.info.exec_()
                            if self.change == 1:
                                self.NoPhooto_StudentList.removeRow(0)
                                self.change = 0
                            self.auto_start()
                            self.auto_start()
                        cv.putText(img, "Collecting photos", (400, 400), cv.FONT_HERSHEY_COMPLEX, 1, (100, 200, 200), 2)
                        if self.pd_k == 1000:
                            self.auto_start()
                    test = str(self.pd_k) + " " + str(self.pd_top) + " " + str(self.pd_left)
                    # cv.putText(img, test, (400, 400), cv.FONT_HERSHEY_COMPLEX, 1, (100, 200, 200), 2)
                cv.rectangle(img, tuple([(mid_left - Length), int(mid_top - unm)]),
                             tuple([(mid_left + Length), int(mid_top + unm)]), (0, 255, 255), 2)

                text = str(mid_left - Length) + "  " + str(mid_left + Length) + "  " + str(mid_top - unm) + "  " + \
                       str(mid_top + unm)
                # cv.putText(img, text, (200, 100), cv.FONT_HERSHEY_COMPLEX, 1, (100, 200, 200), 2)

            # 将opencv的mat类型转化成QT的QImage类型
            height, width, bytesPerComponent = img.shape
            bytesPerLine = bytesPerComponent * width
            # 变换彩色空间顺序
            cv.cvtColor(img, cv.COLOR_BGR2RGB, img)
            # 转为QImage对象
            # img = cv.flip(img, 1)
            image = QImage(img.data, width, height, bytesPerLine, QImage.Format_RGB888)
            # img = cv.flip(img, 1)
            self.VideoArea.setPixmap(QPixmap.fromImage(image).scaled(self.VideoArea.width(), self.VideoArea.height(),
                                                                     aspectRatioMode=Qt.KeepAspectRatio))
            # img = cv.flip(img, 1)
            cv.cvtColor(img, cv.COLOR_RGB2BGR, img)
            cv.namedWindow("camera", cv.WINDOW_NORMAL)
            cv.namedWindow("camera", cv.WINDOW_KEEPRATIO)
            cv.imshow("camera", img)
            cv.cvtColor(img, cv.COLOR_BGR2RGB, img)
            self.VideoArea.show()
            # self.stand_photo_show()

    def getEnd(self, connect):
        self.change = 0
        if connect == 1:
            self.change = 1

    def auto_start(self):
        if self.autoswichs == 0:
            self.autoswichs = 1
            self.pd_k = 1
            self.pd_top = 0
            self.pd_left = 0
            self.autophotograph_2.setText("关闭自动采集")
        else:
            self.autoswichs = 0
            self.autophotograph_2.setText("开启自动采集")

    def take(self):
        if self.cap.isOpened():
            ret, img = self.cap.read()
            img = cv.transpose(img)
            img = cv.flip(img, 0)
            img = cv.flip(img, 1)

            img_gray = cv.cvtColor(img, cv.COLOR_RGB2GRAY)

            # 人脸数
            faces = self.detector(img_gray, 0)

            # 待会要写的字体
            font = cv.FONT_HERSHEY_SIMPLEX

            max_area = 0
            max_face = 0
            # 检测到人脸
            if len(faces) > 0:
                # 记录每次开始写入人脸像素的宽度位置
                for k, face in enumerate(faces):
                    height = face.bottom() - face.top()
                    width = face.right() - face.left()
                    area = height * width
                    if (area > max_area):
                        max_area = area
                        max_face = face

                face = max_face
                # 绘制脸部矩形框
                Length = face.right() - face.left()
                width = face.bottom() - face.top()

                Length = int(Length * 1)
                width = int(width * 0.9)

                op = 1
                Length *= op
                unm = Length * 4 // 3
                mid_left = (face.right() + face.left()) * op // 2
                mid_top = (face.top() + face.bottom()) * op // 2
                # cv.rectangle(img, tuple([(mid_left - Length), int(mid_top - unm)]),
                #            tuple([(mid_left + Length), int(mid_top + unm)]), (0, 255, 255), 2)

                h, w, bytesPerComponent = img.shape
                top = max(mid_top - unm, 0)
                bottom = min(mid_top + unm, h)
                left = max(mid_left - Length, 0)
                right = min(mid_left + Length, w)

                # 截取头像图片
                img = img[top:bottom, left:right]
            else:
                print("No face")
                self.message_send(4)
                return

            # self.add(img)
            img_1 = cv.resize(img, (415, 581), interpolation=cv.INTER_LINEAR)
            cv.namedWindow("camera1", 1)
            cv.imshow("camera1", img_1)

            cv.cvtColor(img, cv.COLOR_BGR2RGB, img)
            # self.add(img)

            # path = os.path.abspath(os.path.dirname(sys.argv[0]))
            # cv.imwrite(path + "/photo/" + self.NoPhooto_StudentList.item(0, 0).text() + "_" +
            #            self.NoPhooto_StudentList.item(0, 1).text()) + ".jpg", img)
            cv.cvtColor(img, cv.COLOR_RGB2BGR, img)
            item = self.NoPhooto_StudentList.item(0, 0)
            name = "default"
            if item is not None:
                n1 = self.NoPhooto_StudentList.item(0, 0).text()
                n2 = self.NoPhooto_StudentList.item(0, 1).text()
                # name = n1 + "_" + n2
                name = n2
                self.NoPhooto_StudentList.removeRow(0)
            cv.imwrite(path + "/photo/" + name + ".jpg", img)
            # cv.namedWindow("s", 1)
            # cv.imshow("s", img)
            # cv.cvtColor(img, cv.COLOR_BGR2RGB, img)
            # image.save(r"test.jpg", "JPG", 100)
            # self.message_send(1)

    def add(self, img):
        # 添加到图片库
        item = self.StudentList.selectedItems()
        if len(item) != 0:
            self.name_arr.append(item[0].text())
        else:
            self.name_arr.append("default")
        self.photo_arr.append(img)
        self.num_photo += 1
        # self.makeup()

    # 生成图片展示框
    def makeup(self):

        self.Photo.clear()
        for i in range(self.num_photo):
            img = self.photo_arr[i]

            # 转化图片格式
            height, width, bytesPerComponent = img.shape
            bytesPerLine = bytesPerComponent * width
            # 变换彩色空间顺序
            # cv.cvtColor(img, cv.COLOR_BGR2RGB, img)
            # 转为QImage对象
            image = QImage(img.data.tobytes(), width, height, bytesPerLine, QImage.Format_RGB888)

            # 生成图片缩略图
            label = QLabel(self)
            # label.resize(self.width, self.width * 4 // 3)
            # 设置图片自动填充 label
            label.setScaledContents(True)

            label.setPixmap(QPixmap.fromImage(image).scaled(60, 80))

            label.setFixedWidth(60)
            label.setFixedHeight(80)

            self.Photo.setCellWidget(i // 4, i % 4, label)
            # 删除 label 对象，防止后期无法即时刷新界面
            # 因为 label 的生存周期未结束
            del label

    # 标准图片
    def stand_photo_init(self):
        self.Stand_img.append(QImage("source/stand_1.jpg"))
        self.cnt_stand = 0
        self.stand_photo_show()

    def add_stand_photo(self):
        img_names, _ = QFileDialog.getOpenFileNames(self, 'Open Standard photo', './',
                                                    'JPG File(*.jpg);;PNG File(*.png)')
        for i in range(len(img_names)):
            self.Stand_img.append(QImage(img_names[i]))
        self.cnt_stand = len(self.Stand_img) - 1
        self.stand_photo_show()

    def stand_photo_next(self):
        self.cnt_stand += 1
        if self.cnt_stand == len(self.Stand_img):
            self.cnt_stand = 0
        self.stand_photo_show()

    def stand_photo_last(self):
        self.cnt_stand -= 1
        if self.cnt_stand < 0:
            self.cnt_stand = len(self.Stand_img) - 1
        self.stand_photo_show()

    def stand_photo_show(self):
        self.Stand_Photo.setPixmap(QPixmap.fromImage(self.Stand_img[self.cnt_stand]).scaled(self.Stand_Photo.width(),
                                                                                            self.Stand_Photo.height(),
                                                                                            aspectRatioMode=Qt.KeepAspectRatio))
        self.Stand_Photo.show()

    def set_New_name(self):
        self.Name.setText(self.NoPhooto_StudentList.item(0, 0).text() + "  " +
                          self.NoPhooto_StudentList.item(0, 1).text())


class Info(QDialog, Ui_Form):
    mySignal = pyqtSignal(int)
    path = os.path.abspath(os.path.dirname(sys.argv[0]))
    img1 = 0
    img2 = 0
    img3 = 0
    name = "0"

    def __init__(self, name, parent=None):
        # 继承主窗口类
        super(Info, self).__init__(parent)
        self.setWindowFlags(Qt.WindowCloseButtonHint)
        # self.setWindowIcon(QIcon('source/book.png'))
        self.setWindowTitle(name)
        self.setupUi(self)
        self.setFixedSize(self.size())
        self.name = name

        xsmap = QPixmap("source/kk1.jpg")
        self.img1 = xsmap
        icon = QIcon(xsmap.scaled(999, 999, Qt.KeepAspectRatio, Qt.SmoothTransformation))
        self.pushButton.setIcon(icon)
        self.pushButton.setIconSize(QSize(260, 400))
        self.pushButton.clicked.connect(self.but_1)

        xsmap = QPixmap("source/kk2.jpg")
        self.img2 = xsmap
        icon = QIcon(xsmap.scaled(999, 999, Qt.KeepAspectRatio, Qt.SmoothTransformation))
        self.pushButton_2.setIcon(icon)
        self.pushButton_2.setIconSize(QSize(260, 400))
        self.pushButton_2.clicked.connect(self.but_2)

        xsmap = QPixmap("source/kk3.jpg")
        self.img3 = xsmap
        icon = QIcon(xsmap.scaled(999, 999, Qt.KeepAspectRatio, Qt.SmoothTransformation))
        self.pushButton_3.setIcon(icon)
        self.pushButton_3.setIconSize(QSize(260, 400))
        self.pushButton_3.clicked.connect(self.but_3)

    def but_1(self):
        self.img1.save("photo/" + self.name + ".jpg", "JPG")
        self.mySignal.emit(1)
        self.close()

    def but_2(self):
        self.img2.save("photo/" + self.name + ".jpg", "JPG")
        self.mySignal.emit(1)
        self.close()

    def but_3(self):
        self.img3.save("photo/" + self.name + ".jpg", "JPG")
        self.mySignal.emit(1)
        self.close()


class Indo(QWidget, Ui_info):
    def __init__(self, parent=None):
        # 继承主窗口类
        super(Indo, self).__init__(parent)
        self.setWindowFlags(Qt.WindowCloseButtonHint)
        self.setWindowIcon(QIcon('source/book.png'))
        self.setupUi(self)
        self.setFixedSize(self.size())


# create by libin


if __name__ == '__main__':
    path = os.path.abspath(os.path.dirname(sys.argv[0]))
    app = QApplication(sys.argv)
    camera = Camera()
    info = Indo()
    camera.infobar.triggered.connect(info.show)
    camera.show()
    sys.exit(app.exec_())
